\hypertarget{namespaceintel_1_1hexl}{}\section{intel\+:\+:hexl Namespace Reference}
\label{namespaceintel_1_1hexl}\index{intel\+::hexl@{intel\+::hexl}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classintel_1_1hexl_1_1AlignedAllocator}{Aligned\+Allocator}
\begin{DoxyCompactList}\small\item\em Allocates memory aligned to Alignment-\/byte sized boundaries. \end{DoxyCompactList}\item 
struct \hyperlink{structintel_1_1hexl_1_1AllocatorBase}{Allocator\+Base}
\begin{DoxyCompactList}\small\item\em Base class for custom memory allocator. \end{DoxyCompactList}\item 
struct \hyperlink{structintel_1_1hexl_1_1AllocatorInterface}{Allocator\+Interface}
\begin{DoxyCompactList}\small\item\em Helper memory allocation struct which delegates implementation to Allocator\+Impl. \end{DoxyCompactList}\item 
struct \hyperlink{structintel_1_1hexl_1_1MallocStrategy}{Malloc\+Strategy}
\begin{DoxyCompactList}\small\item\em Allocater implementation using malloc and free. \end{DoxyCompactList}\item 
class \hyperlink{classintel_1_1hexl_1_1MultiplyFactor}{Multiply\+Factor}
\begin{DoxyCompactList}\small\item\em Pre-\/computes a Barrett factor with which modular multiplication can be performed more efficiently. \end{DoxyCompactList}\item 
class \hyperlink{classintel_1_1hexl_1_1NTT}{N\+TT}
\begin{DoxyCompactList}\small\item\em Performs negacyclic forward and inverse number-\/theoretic transform (\hyperlink{classintel_1_1hexl_1_1NTT}{N\+TT}), commonly used in R\+L\+WE cryptography. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \hyperlink{namespaceintel_1_1hexl_aced64250965d3b78827d8009634eef0c}{Allocator\+Strategy\+Ptr} = std\+::shared\+\_\+ptr$<$ \hyperlink{structintel_1_1hexl_1_1AllocatorBase}{Allocator\+Base} $>$
\item 
{\footnotesize template$<$typename T $>$ }\\using \hyperlink{namespaceintel_1_1hexl_afbdf0d2cc4209ee547a88ff22a02801b}{Aligned\+Vector64} = std\+::vector$<$ T, \hyperlink{classintel_1_1hexl_1_1AlignedAllocator}{Aligned\+Allocator}$<$ T, 64 $>$ $>$
\begin{DoxyCompactList}\small\item\em 64-\/byte aligned memory allocator \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006}{C\+M\+P\+I\+NT} \{ \newline
\hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006a2dcbad7477fd40561e8b8198f173bd47}{C\+M\+P\+I\+N\+T\+::\+EQ} = 0, 
\hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006ac562607189d77eb9dfb707464c1e7b0b}{C\+M\+P\+I\+N\+T\+::\+LT} = 1, 
\hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006acfe6055d2e0503be378bb63449ec7ba6}{C\+M\+P\+I\+N\+T\+::\+LE} = 2, 
\hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006a946003f97ccc52d5d3b54ac0ec31bbfc}{C\+M\+P\+I\+N\+T\+::\+F\+A\+L\+SE} = 3, 
\newline
\hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006adc33066c3993e0d50896e533fd692ce0}{C\+M\+P\+I\+N\+T\+::\+NE} = 4, 
\hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006ad7d6a13c7b311ec8a3c9fcfb1919a2f8}{C\+M\+P\+I\+N\+T\+::\+N\+LT} = 5, 
\hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006aacd748f300c5d189c47807e2a9d6ea57}{C\+M\+P\+I\+N\+T\+::\+N\+LE} = 6, 
\hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006ac0d83f0b82a6b30de8811e69e6d95c61}{C\+M\+P\+I\+N\+T\+::\+T\+R\+UE} = 7
 \}\begin{DoxyCompactList}\small\item\em Represents binary operations between two boolean values. \end{DoxyCompactList}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{namespaceintel_1_1hexl_a319244a133f57825ba7e593ad5c71709}{Eltwise\+Add\+Mod} (uint64\+\_\+t $\ast$result, const uint64\+\_\+t $\ast$operand1, const uint64\+\_\+t $\ast$operand2, uint64\+\_\+t n, uint64\+\_\+t modulus)
\begin{DoxyCompactList}\small\item\em Adds two vectors elementwise with modular reduction. \end{DoxyCompactList}\item 
void \hyperlink{namespaceintel_1_1hexl_a8e0884463658eae11b6f1c6dfeb50b40}{Eltwise\+Add\+Mod} (uint64\+\_\+t $\ast$result, const uint64\+\_\+t $\ast$operand1, uint64\+\_\+t operand2, uint64\+\_\+t n, uint64\+\_\+t modulus)
\begin{DoxyCompactList}\small\item\em Adds a vector and scalar elementwise with modular reduction. \end{DoxyCompactList}\item 
void \hyperlink{namespaceintel_1_1hexl_a5c4fd2ceb53b94efa5f5a959d7ee9819}{Eltwise\+Cmp\+Add} (uint64\+\_\+t $\ast$result, const uint64\+\_\+t $\ast$operand1, uint64\+\_\+t n, \hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006}{C\+M\+P\+I\+NT} cmp, uint64\+\_\+t bound, uint64\+\_\+t diff)
\begin{DoxyCompactList}\small\item\em Computes element-\/wise conditional addition. \end{DoxyCompactList}\item 
void \hyperlink{namespaceintel_1_1hexl_a78bf86d32140e39d8f99d474ccd0e226}{Eltwise\+Cmp\+Sub\+Mod} (uint64\+\_\+t $\ast$result, const uint64\+\_\+t $\ast$operand1, uint64\+\_\+t n, uint64\+\_\+t modulus, \hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006}{C\+M\+P\+I\+NT} cmp, uint64\+\_\+t bound, uint64\+\_\+t diff)
\begin{DoxyCompactList}\small\item\em Computes element-\/wise conditional modular subtraction. \end{DoxyCompactList}\item 
void \hyperlink{namespaceintel_1_1hexl_a5b65d563391b4a1a5041633aeb118aa5}{Eltwise\+F\+M\+A\+Mod} (uint64\+\_\+t $\ast$result, const uint64\+\_\+t $\ast$arg1, uint64\+\_\+t arg2, const uint64\+\_\+t $\ast$arg3, uint64\+\_\+t n, uint64\+\_\+t modulus, uint64\+\_\+t input\+\_\+mod\+\_\+factor)
\begin{DoxyCompactList}\small\item\em Computes fused multiply-\/add ({\ttfamily arg1} $\ast$ {\ttfamily arg2} + {\ttfamily arg3}) mod {\ttfamily modulus} element-\/wise, broadcasting scalars to vectors. \end{DoxyCompactList}\item 
void \hyperlink{namespaceintel_1_1hexl_a705bc0321d937ae4d1f8d50279e3cff1}{Eltwise\+Mult\+Mod} (uint64\+\_\+t $\ast$result, const uint64\+\_\+t $\ast$operand1, const uint64\+\_\+t $\ast$operand2, uint64\+\_\+t n, uint64\+\_\+t modulus, uint64\+\_\+t input\+\_\+mod\+\_\+factor)
\begin{DoxyCompactList}\small\item\em Multiplies two vectors elementwise with modular reduction. \end{DoxyCompactList}\item 
void \hyperlink{namespaceintel_1_1hexl_af3ddae165283841d495a322275baf5ee}{Eltwise\+Reduce\+Mod} (uint64\+\_\+t $\ast$result, const uint64\+\_\+t $\ast$operand, uint64\+\_\+t n, uint64\+\_\+t modulus, uint64\+\_\+t input\+\_\+mod\+\_\+factor, uint64\+\_\+t output\+\_\+mod\+\_\+factor)
\begin{DoxyCompactList}\small\item\em Performs elementwise modular reduction. \end{DoxyCompactList}\item 
void \hyperlink{namespaceintel_1_1hexl_a6a45c30bc21b9b1e1410b23fce5424c8}{Eltwise\+Sub\+Mod} (uint64\+\_\+t $\ast$result, const uint64\+\_\+t $\ast$operand1, const uint64\+\_\+t $\ast$operand2, uint64\+\_\+t n, uint64\+\_\+t modulus)
\begin{DoxyCompactList}\small\item\em Subtracts two vectors elementwise with modular reduction. \end{DoxyCompactList}\item 
void \hyperlink{namespaceintel_1_1hexl_abc13b8f383d3af6471a5261ee2213b40}{Eltwise\+Sub\+Mod} (uint64\+\_\+t $\ast$result, const uint64\+\_\+t $\ast$operand1, uint64\+\_\+t operand2, uint64\+\_\+t n, uint64\+\_\+t modulus)
\begin{DoxyCompactList}\small\item\em Subtracts a scalar from a vector elementwise with modular reduction. \end{DoxyCompactList}\item 
void \hyperlink{namespaceintel_1_1hexl_a287608abb254a6f0eeb3c7ca95e85a71}{Ckks\+Multiply} (uint64\+\_\+t $\ast$result, const uint64\+\_\+t $\ast$operand1, const uint64\+\_\+t $\ast$operand2, uint64\+\_\+t n, const uint64\+\_\+t $\ast$moduli, uint64\+\_\+t num\+\_\+moduli)
\begin{DoxyCompactList}\small\item\em Computes C\+K\+KS multiplication. \end{DoxyCompactList}\item 
void \hyperlink{namespaceintel_1_1hexl_ae983051ff4c3321db4db4569d7fbe796}{Ckks\+Switch\+Key} (uint64\+\_\+t $\ast$result, const uint64\+\_\+t $\ast$t\+\_\+target\+\_\+iter\+\_\+ptr, uint64\+\_\+t n, uint64\+\_\+t decomp\+\_\+modulus\+\_\+size, uint64\+\_\+t key\+\_\+modulus\+\_\+size, uint64\+\_\+t rns\+\_\+modulus\+\_\+size, uint64\+\_\+t key\+\_\+component\+\_\+count, uint64\+\_\+t $\ast$moduli, const uint64\+\_\+t $\ast$$\ast$kswitch\+\_\+keys, uint64\+\_\+t $\ast$modswitch\+\_\+factors)
\begin{DoxyCompactList}\small\item\em Computes C\+K\+KS key switching in-\/place. \end{DoxyCompactList}\item 
bool \hyperlink{namespaceintel_1_1hexl_ada0fe74afb4384b54728cba8ec3f69cd}{Is\+Power\+Of\+Two} (uint64\+\_\+t num)
\begin{DoxyCompactList}\small\item\em Returns whether or not num is a power of two. \end{DoxyCompactList}\item 
uint64\+\_\+t \hyperlink{namespaceintel_1_1hexl_a066a83a4b122279313279a58cf440004}{Log2} (uint64\+\_\+t x)
\begin{DoxyCompactList}\small\item\em Returns floor(log2(x)) \end{DoxyCompactList}\item 
bool \hyperlink{namespaceintel_1_1hexl_a74a77227ebbd892a0cff5089f3d89010}{Is\+Power\+Of\+Four} (uint64\+\_\+t num)
\item 
uint64\+\_\+t \hyperlink{namespaceintel_1_1hexl_a9975ccaf5ec051c07ff4e3fef5c1fefb}{Maximum\+Value} (uint64\+\_\+t bits)
\begin{DoxyCompactList}\small\item\em Returns the maximum value that can be represented using {\ttfamily bits} bits. \end{DoxyCompactList}\item 
uint64\+\_\+t \hyperlink{namespaceintel_1_1hexl_aa48183a39af615227d5b14c0fdb46105}{Reverse\+Bits} (uint64\+\_\+t x, uint64\+\_\+t bit\+\_\+width)
\begin{DoxyCompactList}\small\item\em Reverses the bits. \end{DoxyCompactList}\item 
uint64\+\_\+t \hyperlink{namespaceintel_1_1hexl_ac949027d43c64d65400c93a148d349c6}{Inverse\+Mod} (uint64\+\_\+t x, uint64\+\_\+t modulus)
\begin{DoxyCompactList}\small\item\em Returns x$^\wedge$\{-\/1\} mod modulus. \end{DoxyCompactList}\item 
uint64\+\_\+t \hyperlink{namespaceintel_1_1hexl_a838d9c2d540f99b349546461dee63252}{Multiply\+Mod} (uint64\+\_\+t x, uint64\+\_\+t y, uint64\+\_\+t modulus)
\begin{DoxyCompactList}\small\item\em Returns (x $\ast$ y) mod modulus. \end{DoxyCompactList}\item 
uint64\+\_\+t \hyperlink{namespaceintel_1_1hexl_a0b3d06107428b15f58be1680fbf1656d}{Multiply\+Mod} (uint64\+\_\+t x, uint64\+\_\+t y, uint64\+\_\+t y\+\_\+precon, uint64\+\_\+t modulus)
\begin{DoxyCompactList}\small\item\em Returns (x $\ast$ y) mod modulus. \end{DoxyCompactList}\item 
uint64\+\_\+t \hyperlink{namespaceintel_1_1hexl_ad16852e2b8114cd9c22dd25593c76f99}{Add\+U\+Int\+Mod} (uint64\+\_\+t x, uint64\+\_\+t y, uint64\+\_\+t modulus)
\begin{DoxyCompactList}\small\item\em Returns (x + y) mod modulus. \end{DoxyCompactList}\item 
uint64\+\_\+t \hyperlink{namespaceintel_1_1hexl_a4411ec648d83bfbc3ecaf96859576054}{Sub\+U\+Int\+Mod} (uint64\+\_\+t x, uint64\+\_\+t y, uint64\+\_\+t modulus)
\begin{DoxyCompactList}\small\item\em Returns (x -\/ y) mod modulus. \end{DoxyCompactList}\item 
uint64\+\_\+t \hyperlink{namespaceintel_1_1hexl_aff7287aeef7fdb27e6ffb254adb40477}{Pow\+Mod} (uint64\+\_\+t base, uint64\+\_\+t exp, uint64\+\_\+t modulus)
\begin{DoxyCompactList}\small\item\em Returns base$^\wedge$exp mod modulus. \end{DoxyCompactList}\item 
bool \hyperlink{namespaceintel_1_1hexl_a8b04aa9aed381d3c976d953efbe0a4b6}{Is\+Primitive\+Root} (uint64\+\_\+t root, uint64\+\_\+t degree, uint64\+\_\+t modulus)
\begin{DoxyCompactList}\small\item\em Returns whether or not root is a degree-\/th root of unity mod modulus. \end{DoxyCompactList}\item 
uint64\+\_\+t \hyperlink{namespaceintel_1_1hexl_a130d3fb9218c1aaa9fbeb5d143eb288b}{Generate\+Primitive\+Root} (uint64\+\_\+t degree, uint64\+\_\+t modulus)
\begin{DoxyCompactList}\small\item\em Tries to return a primitive degree-\/th root of unity. \end{DoxyCompactList}\item 
uint64\+\_\+t \hyperlink{namespaceintel_1_1hexl_adcc30a762adcbbdc9d7ebefa6fffe83b}{Minimal\+Primitive\+Root} (uint64\+\_\+t degree, uint64\+\_\+t modulus)
\begin{DoxyCompactList}\small\item\em Returns whether or not root is a degree-\/th root of unity. \end{DoxyCompactList}\item 
{\footnotesize template$<$int Bit\+Shift$>$ }\\uint64\+\_\+t \hyperlink{namespaceintel_1_1hexl_ad7a9d35f74908eca9240bc7675705976}{Multiply\+Mod\+Lazy} (uint64\+\_\+t x, uint64\+\_\+t y\+\_\+operand, uint64\+\_\+t y\+\_\+barrett\+\_\+factor, uint64\+\_\+t modulus)
\begin{DoxyCompactList}\small\item\em Computes (x $\ast$ y) mod modulus, except that the output is in \mbox{[}0, 2 $\ast$ modulus\mbox{]}. \end{DoxyCompactList}\item 
{\footnotesize template$<$int Bit\+Shift$>$ }\\uint64\+\_\+t \hyperlink{namespaceintel_1_1hexl_a8f6c714aff229c45fbba359cc67331a5}{Multiply\+Mod\+Lazy} (uint64\+\_\+t x, uint64\+\_\+t y, uint64\+\_\+t modulus)
\begin{DoxyCompactList}\small\item\em Computes (x $\ast$ y) mod modulus, except that the output is in \mbox{[}0, 2 $\ast$ modulus\mbox{]}. \end{DoxyCompactList}\item 
unsigned char \hyperlink{namespaceintel_1_1hexl_a3ecce7e5a5591605703890fb3b2b6d80}{Add\+U\+Int64} (uint64\+\_\+t operand1, uint64\+\_\+t operand2, uint64\+\_\+t $\ast$result)
\begin{DoxyCompactList}\small\item\em Adds two unsigned 64-\/bit integers. \end{DoxyCompactList}\item 
bool \hyperlink{namespaceintel_1_1hexl_a1155b31afc84bd8a7080d49b66480395}{Is\+Prime} (uint64\+\_\+t n)
\begin{DoxyCompactList}\small\item\em Returns whether or not the input is prime. \end{DoxyCompactList}\item 
std\+::vector$<$ uint64\+\_\+t $>$ \hyperlink{namespaceintel_1_1hexl_a3a8c240e5282f1d89c281527a842ae3d}{Generate\+Primes} (size\+\_\+t num\+\_\+primes, size\+\_\+t bit\+\_\+size, bool prefer\+\_\+small\+\_\+primes, size\+\_\+t ntt\+\_\+size=1)
\begin{DoxyCompactList}\small\item\em Generates a list of num\+\_\+primes primes in the range \mbox{[}2$^\wedge$(bit\+\_\+size),. \end{DoxyCompactList}\item 
uint64\+\_\+t \hyperlink{namespaceintel_1_1hexl_aebdaa3e2bf7c73ec0dacd465c69f2969}{Barrett\+Reduce64} (uint64\+\_\+t input, uint64\+\_\+t modulus, uint64\+\_\+t q\+\_\+barr)
\begin{DoxyCompactList}\small\item\em Returns input mod modulus, computed via 64-\/bit Barrett reduction. \end{DoxyCompactList}\item 
{\footnotesize template$<$int Input\+Mod\+Factor$>$ }\\uint64\+\_\+t \hyperlink{namespaceintel_1_1hexl_ab716e0395cbfe58e76f866a9044f2a62}{Reduce\+Mod} (uint64\+\_\+t x, uint64\+\_\+t modulus, const uint64\+\_\+t $\ast$twice\+\_\+modulus=nullptr, const uint64\+\_\+t $\ast$four\+\_\+times\+\_\+modulus=nullptr)
\begin{DoxyCompactList}\small\item\em Returns x mod modulus, assuming x $<$ Input\+Mod\+Factor $\ast$ modulus. \end{DoxyCompactList}\item 
\hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006}{C\+M\+P\+I\+NT} \hyperlink{namespaceintel_1_1hexl_a8c654502a5e7fe2cfdd198f0fd920f2a}{Not} (\hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006}{C\+M\+P\+I\+NT} cmp)
\begin{DoxyCompactList}\small\item\em Returns the logical negation of a binary operation. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\hyperlink{namespaceintel_1_1hexl_aced64250965d3b78827d8009634eef0c}{Allocator\+Strategy\+Ptr} \hyperlink{namespaceintel_1_1hexl_aedc86b34ea92ac34d036acff6d84479a}{malloc\+Strategy}
\end{DoxyCompactItemize}


\subsection{Typedef Documentation}
\mbox{\Hypertarget{namespaceintel_1_1hexl_afbdf0d2cc4209ee547a88ff22a02801b}\label{namespaceintel_1_1hexl_afbdf0d2cc4209ee547a88ff22a02801b}} 
\index{intel\+::hexl@{intel\+::hexl}!Aligned\+Vector64@{Aligned\+Vector64}}
\index{Aligned\+Vector64@{Aligned\+Vector64}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Aligned\+Vector64}{AlignedVector64}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
using \hyperlink{namespaceintel_1_1hexl_afbdf0d2cc4209ee547a88ff22a02801b}{intel\+::hexl\+::\+Aligned\+Vector64} = typedef std\+::vector$<$T, \hyperlink{classintel_1_1hexl_1_1AlignedAllocator}{Aligned\+Allocator}$<$T, 64$>$ $>$}



64-\/byte aligned memory allocator 

\mbox{\Hypertarget{namespaceintel_1_1hexl_aced64250965d3b78827d8009634eef0c}\label{namespaceintel_1_1hexl_aced64250965d3b78827d8009634eef0c}} 
\index{intel\+::hexl@{intel\+::hexl}!Allocator\+Strategy\+Ptr@{Allocator\+Strategy\+Ptr}}
\index{Allocator\+Strategy\+Ptr@{Allocator\+Strategy\+Ptr}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Allocator\+Strategy\+Ptr}{AllocatorStrategyPtr}}
{\footnotesize\ttfamily using \hyperlink{namespaceintel_1_1hexl_aced64250965d3b78827d8009634eef0c}{intel\+::hexl\+::\+Allocator\+Strategy\+Ptr} = typedef std\+::shared\+\_\+ptr$<$\hyperlink{structintel_1_1hexl_1_1AllocatorBase}{Allocator\+Base}$>$}



\subsection{Enumeration Type Documentation}
\mbox{\Hypertarget{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006}\label{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006}} 
\index{intel\+::hexl@{intel\+::hexl}!C\+M\+P\+I\+NT@{C\+M\+P\+I\+NT}}
\index{C\+M\+P\+I\+NT@{C\+M\+P\+I\+NT}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{C\+M\+P\+I\+NT}{CMPINT}}
{\footnotesize\ttfamily enum \hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006}{intel\+::hexl\+::\+C\+M\+P\+I\+NT}\hspace{0.3cm}{\ttfamily [strong]}}



Represents binary operations between two boolean values. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{EQ@{EQ}!intel\+::hexl@{intel\+::hexl}}\index{intel\+::hexl@{intel\+::hexl}!EQ@{EQ}}}\mbox{\Hypertarget{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006a2dcbad7477fd40561e8b8198f173bd47}\label{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006a2dcbad7477fd40561e8b8198f173bd47}} 
EQ&Equal. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{LT@{LT}!intel\+::hexl@{intel\+::hexl}}\index{intel\+::hexl@{intel\+::hexl}!LT@{LT}}}\mbox{\Hypertarget{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006ac562607189d77eb9dfb707464c1e7b0b}\label{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006ac562607189d77eb9dfb707464c1e7b0b}} 
LT&Less than. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{LE@{LE}!intel\+::hexl@{intel\+::hexl}}\index{intel\+::hexl@{intel\+::hexl}!LE@{LE}}}\mbox{\Hypertarget{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006acfe6055d2e0503be378bb63449ec7ba6}\label{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006acfe6055d2e0503be378bb63449ec7ba6}} 
LE&Less than or equal. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{F\+A\+L\+SE@{F\+A\+L\+SE}!intel\+::hexl@{intel\+::hexl}}\index{intel\+::hexl@{intel\+::hexl}!F\+A\+L\+SE@{F\+A\+L\+SE}}}\mbox{\Hypertarget{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006a946003f97ccc52d5d3b54ac0ec31bbfc}\label{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006a946003f97ccc52d5d3b54ac0ec31bbfc}} 
F\+A\+L\+SE&False. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{NE@{NE}!intel\+::hexl@{intel\+::hexl}}\index{intel\+::hexl@{intel\+::hexl}!NE@{NE}}}\mbox{\Hypertarget{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006adc33066c3993e0d50896e533fd692ce0}\label{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006adc33066c3993e0d50896e533fd692ce0}} 
NE&Not equal. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{N\+LT@{N\+LT}!intel\+::hexl@{intel\+::hexl}}\index{intel\+::hexl@{intel\+::hexl}!N\+LT@{N\+LT}}}\mbox{\Hypertarget{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006ad7d6a13c7b311ec8a3c9fcfb1919a2f8}\label{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006ad7d6a13c7b311ec8a3c9fcfb1919a2f8}} 
N\+LT&Not less than. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{N\+LE@{N\+LE}!intel\+::hexl@{intel\+::hexl}}\index{intel\+::hexl@{intel\+::hexl}!N\+LE@{N\+LE}}}\mbox{\Hypertarget{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006aacd748f300c5d189c47807e2a9d6ea57}\label{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006aacd748f300c5d189c47807e2a9d6ea57}} 
N\+LE&Not less than or equal. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{T\+R\+UE@{T\+R\+UE}!intel\+::hexl@{intel\+::hexl}}\index{intel\+::hexl@{intel\+::hexl}!T\+R\+UE@{T\+R\+UE}}}\mbox{\Hypertarget{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006ac0d83f0b82a6b30de8811e69e6d95c61}\label{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006ac0d83f0b82a6b30de8811e69e6d95c61}} 
T\+R\+UE&True. \\
\hline

\end{DoxyEnumFields}


\subsection{Function Documentation}
\mbox{\Hypertarget{namespaceintel_1_1hexl_a3ecce7e5a5591605703890fb3b2b6d80}\label{namespaceintel_1_1hexl_a3ecce7e5a5591605703890fb3b2b6d80}} 
\index{intel\+::hexl@{intel\+::hexl}!Add\+U\+Int64@{Add\+U\+Int64}}
\index{Add\+U\+Int64@{Add\+U\+Int64}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Add\+U\+Int64()}{AddUInt64()}}
{\footnotesize\ttfamily unsigned char intel\+::hexl\+::\+Add\+U\+Int64 (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{operand1,  }\item[{uint64\+\_\+t}]{operand2,  }\item[{uint64\+\_\+t $\ast$}]{result }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Adds two unsigned 64-\/bit integers. 


\begin{DoxyParams}{Parameters}
{\em operand1} & Number to add \\
\hline
{\em operand2} & Number to add \\
\hline
{\em result} & Stores the sum \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The carry bit 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceintel_1_1hexl_ad16852e2b8114cd9c22dd25593c76f99}\label{namespaceintel_1_1hexl_ad16852e2b8114cd9c22dd25593c76f99}} 
\index{intel\+::hexl@{intel\+::hexl}!Add\+U\+Int\+Mod@{Add\+U\+Int\+Mod}}
\index{Add\+U\+Int\+Mod@{Add\+U\+Int\+Mod}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Add\+U\+Int\+Mod()}{AddUIntMod()}}
{\footnotesize\ttfamily uint64\+\_\+t intel\+::hexl\+::\+Add\+U\+Int\+Mod (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{x,  }\item[{uint64\+\_\+t}]{y,  }\item[{uint64\+\_\+t}]{modulus }\end{DoxyParamCaption})}



Returns (x + y) mod modulus. 

Assumes x, y $<$ modulus \mbox{\Hypertarget{namespaceintel_1_1hexl_aebdaa3e2bf7c73ec0dacd465c69f2969}\label{namespaceintel_1_1hexl_aebdaa3e2bf7c73ec0dacd465c69f2969}} 
\index{intel\+::hexl@{intel\+::hexl}!Barrett\+Reduce64@{Barrett\+Reduce64}}
\index{Barrett\+Reduce64@{Barrett\+Reduce64}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Barrett\+Reduce64()}{BarrettReduce64()}}
{\footnotesize\ttfamily uint64\+\_\+t intel\+::hexl\+::\+Barrett\+Reduce64 (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{input,  }\item[{uint64\+\_\+t}]{modulus,  }\item[{uint64\+\_\+t}]{q\+\_\+barr }\end{DoxyParamCaption})}



Returns input mod modulus, computed via 64-\/bit Barrett reduction. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em input} & \\
\hline
\mbox{\tt in}  & {\em modulus} & \\
\hline
\mbox{\tt in}  & {\em q\+\_\+barr} & floor(2$^\wedge$64 / modulus) \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceintel_1_1hexl_a287608abb254a6f0eeb3c7ca95e85a71}\label{namespaceintel_1_1hexl_a287608abb254a6f0eeb3c7ca95e85a71}} 
\index{intel\+::hexl@{intel\+::hexl}!Ckks\+Multiply@{Ckks\+Multiply}}
\index{Ckks\+Multiply@{Ckks\+Multiply}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Ckks\+Multiply()}{CkksMultiply()}}
{\footnotesize\ttfamily void intel\+::hexl\+::\+Ckks\+Multiply (\begin{DoxyParamCaption}\item[{uint64\+\_\+t $\ast$}]{result,  }\item[{const uint64\+\_\+t $\ast$}]{operand1,  }\item[{const uint64\+\_\+t $\ast$}]{operand2,  }\item[{uint64\+\_\+t}]{n,  }\item[{const uint64\+\_\+t $\ast$}]{moduli,  }\item[{uint64\+\_\+t}]{num\+\_\+moduli }\end{DoxyParamCaption})}



Computes C\+K\+KS multiplication. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em result} & Ciphertext data. Will be over-\/written with result. Has (2 $\ast$ n $\ast$ num\+\_\+moduli) elements \\
\hline
\mbox{\tt in}  & {\em operand1} & First ciphertext argument. Has (2 $\ast$ n $\ast$ num\+\_\+moduli) elements. \\
\hline
\mbox{\tt in}  & {\em operand2} & Second ciphertext argument. Has (2 $\ast$ n $\ast$ num\+\_\+moduli) elements. \\
\hline
\mbox{\tt in}  & {\em n} & Number of coefficients in each polynomial \\
\hline
\mbox{\tt in}  & {\em moduli} & Pointer to contiguous array of num\+\_\+moduli word-\/sized coefficient moduli \\
\hline
\mbox{\tt in}  & {\em num\+\_\+moduli} & Number of word-\/sized coefficient moduli \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceintel_1_1hexl_ae983051ff4c3321db4db4569d7fbe796}\label{namespaceintel_1_1hexl_ae983051ff4c3321db4db4569d7fbe796}} 
\index{intel\+::hexl@{intel\+::hexl}!Ckks\+Switch\+Key@{Ckks\+Switch\+Key}}
\index{Ckks\+Switch\+Key@{Ckks\+Switch\+Key}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Ckks\+Switch\+Key()}{CkksSwitchKey()}}
{\footnotesize\ttfamily void intel\+::hexl\+::\+Ckks\+Switch\+Key (\begin{DoxyParamCaption}\item[{uint64\+\_\+t $\ast$}]{result,  }\item[{const uint64\+\_\+t $\ast$}]{t\+\_\+target\+\_\+iter\+\_\+ptr,  }\item[{uint64\+\_\+t}]{n,  }\item[{uint64\+\_\+t}]{decomp\+\_\+modulus\+\_\+size,  }\item[{uint64\+\_\+t}]{key\+\_\+modulus\+\_\+size,  }\item[{uint64\+\_\+t}]{rns\+\_\+modulus\+\_\+size,  }\item[{uint64\+\_\+t}]{key\+\_\+component\+\_\+count,  }\item[{uint64\+\_\+t $\ast$}]{moduli,  }\item[{const uint64\+\_\+t $\ast$$\ast$}]{kswitch\+\_\+keys,  }\item[{uint64\+\_\+t $\ast$}]{modswitch\+\_\+factors }\end{DoxyParamCaption})}



Computes C\+K\+KS key switching in-\/place. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em result} & Ciphertext data. Will be over-\/written with result. Has (n $\ast$ decomp\+\_\+modulus\+\_\+size $\ast$ key\+\_\+component\+\_\+count) elements \\
\hline
\mbox{\tt in}  & {\em t\+\_\+target\+\_\+iter\+\_\+ptr} & T\+O\+D\+O(fboemer) \\
\hline
\mbox{\tt in}  & {\em n} & Number of coefficients in each polynomial \\
\hline
\mbox{\tt in}  & {\em decomp\+\_\+modulus\+\_\+size} & Number of moduli in the ciphertext at its current level, excluding one auxiliary prime. \\
\hline
\mbox{\tt in}  & {\em key\+\_\+modulus\+\_\+size} & Number of moduli in the ciphertext at its top level, including one auxiliary prime. \\
\hline
\mbox{\tt in}  & {\em rns\+\_\+modulus\+\_\+size} & Number of moduli in the ciphertext at its current level, including one auxiliary prime. rns\+\_\+modulus\+\_\+size == decomp\+\_\+modulus\+\_\+size + 1 \\
\hline
\mbox{\tt in}  & {\em key\+\_\+component\+\_\+count} & T\+O\+D\+O(fboemer) \\
\hline
\mbox{\tt in}  & {\em moduli} & Array of word-\/sized coefficient moduli. There must be key\+\_\+modulus\+\_\+size moduli in the array \\
\hline
\mbox{\tt in}  & {\em kswitch\+\_\+keys} & Array of evaluation key data. Has decomp\+\_\+modulus\+\_\+size entries, each with coeff\+\_\+count $\ast$ ((key\+\_\+modulus\+\_\+size -\/ 1)+ (key\+\_\+component\+\_\+count -\/ 1) $\ast$ (key\+\_\+modulus\+\_\+size) + 1) entries \\
\hline
\mbox{\tt in}  & {\em modswitch\+\_\+factors} & Array of modulus switch factors \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceintel_1_1hexl_a319244a133f57825ba7e593ad5c71709}\label{namespaceintel_1_1hexl_a319244a133f57825ba7e593ad5c71709}} 
\index{intel\+::hexl@{intel\+::hexl}!Eltwise\+Add\+Mod@{Eltwise\+Add\+Mod}}
\index{Eltwise\+Add\+Mod@{Eltwise\+Add\+Mod}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Eltwise\+Add\+Mod()}{EltwiseAddMod()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void intel\+::hexl\+::\+Eltwise\+Add\+Mod (\begin{DoxyParamCaption}\item[{uint64\+\_\+t $\ast$}]{result,  }\item[{const uint64\+\_\+t $\ast$}]{operand1,  }\item[{const uint64\+\_\+t $\ast$}]{operand2,  }\item[{uint64\+\_\+t}]{n,  }\item[{uint64\+\_\+t}]{modulus }\end{DoxyParamCaption})}



Adds two vectors elementwise with modular reduction. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em result} & Stores result \\
\hline
\mbox{\tt in}  & {\em operand1} & Vector of elements to add. Each element must be less than the modulus \\
\hline
\mbox{\tt in}  & {\em operand2} & Vector of elements to add. Each element must be less than the modulus \\
\hline
\mbox{\tt in}  & {\em n} & Number of elements in each vector \\
\hline
\mbox{\tt in}  & {\em modulus} & Modulus with which to perform modular reduction. Must be in the range $[2, 2^{63} - 1]$\\
\hline
\end{DoxyParams}
Computes $ operand1[i] = (operand1[i] + operand2[i]) \mod modulus $ for $ i=0, ..., n-1$. \mbox{\Hypertarget{namespaceintel_1_1hexl_a8e0884463658eae11b6f1c6dfeb50b40}\label{namespaceintel_1_1hexl_a8e0884463658eae11b6f1c6dfeb50b40}} 
\index{intel\+::hexl@{intel\+::hexl}!Eltwise\+Add\+Mod@{Eltwise\+Add\+Mod}}
\index{Eltwise\+Add\+Mod@{Eltwise\+Add\+Mod}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Eltwise\+Add\+Mod()}{EltwiseAddMod()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void intel\+::hexl\+::\+Eltwise\+Add\+Mod (\begin{DoxyParamCaption}\item[{uint64\+\_\+t $\ast$}]{result,  }\item[{const uint64\+\_\+t $\ast$}]{operand1,  }\item[{uint64\+\_\+t}]{operand2,  }\item[{uint64\+\_\+t}]{n,  }\item[{uint64\+\_\+t}]{modulus }\end{DoxyParamCaption})}



Adds a vector and scalar elementwise with modular reduction. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em result} & Stores result \\
\hline
\mbox{\tt in}  & {\em operand1} & Vector of elements to add. Each element must be less than the modulus \\
\hline
\mbox{\tt in}  & {\em operand2} & Scalar to add. Must be less than the modulus \\
\hline
\mbox{\tt in}  & {\em n} & Number of elements in each vector \\
\hline
\mbox{\tt in}  & {\em modulus} & Modulus with which to perform modular reduction. Must be in the range $[2, 2^{63} - 1]$\\
\hline
\end{DoxyParams}
Computes $ operand1[i] = (operand1[i] + operand2) \mod modulus $ for $ i=0, ..., n-1$. \mbox{\Hypertarget{namespaceintel_1_1hexl_a5c4fd2ceb53b94efa5f5a959d7ee9819}\label{namespaceintel_1_1hexl_a5c4fd2ceb53b94efa5f5a959d7ee9819}} 
\index{intel\+::hexl@{intel\+::hexl}!Eltwise\+Cmp\+Add@{Eltwise\+Cmp\+Add}}
\index{Eltwise\+Cmp\+Add@{Eltwise\+Cmp\+Add}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Eltwise\+Cmp\+Add()}{EltwiseCmpAdd()}}
{\footnotesize\ttfamily void intel\+::hexl\+::\+Eltwise\+Cmp\+Add (\begin{DoxyParamCaption}\item[{uint64\+\_\+t $\ast$}]{result,  }\item[{const uint64\+\_\+t $\ast$}]{operand1,  }\item[{uint64\+\_\+t}]{n,  }\item[{\hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006}{C\+M\+P\+I\+NT}}]{cmp,  }\item[{uint64\+\_\+t}]{bound,  }\item[{uint64\+\_\+t}]{diff }\end{DoxyParamCaption})}



Computes element-\/wise conditional addition. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em result} & Stores the result \\
\hline
\mbox{\tt in}  & {\em operand1} & Vector of elements to compare; stores result \\
\hline
\mbox{\tt in}  & {\em n} & Number of elements in {\ttfamily operand1} \\
\hline
\mbox{\tt in}  & {\em cmp} & Comparison operation \\
\hline
\mbox{\tt in}  & {\em bound} & Scalar to compare against \\
\hline
\mbox{\tt in}  & {\em diff} & Scalar to conditionally add\\
\hline
\end{DoxyParams}
Computes result\mbox{[}i\mbox{]} = cmp(operand1\mbox{[}i\mbox{]}, bound) ? operand1\mbox{[}i\mbox{]} + diff \+: operand1\mbox{[}i\mbox{]} for all $i=0, ..., n-1$. \mbox{\Hypertarget{namespaceintel_1_1hexl_a78bf86d32140e39d8f99d474ccd0e226}\label{namespaceintel_1_1hexl_a78bf86d32140e39d8f99d474ccd0e226}} 
\index{intel\+::hexl@{intel\+::hexl}!Eltwise\+Cmp\+Sub\+Mod@{Eltwise\+Cmp\+Sub\+Mod}}
\index{Eltwise\+Cmp\+Sub\+Mod@{Eltwise\+Cmp\+Sub\+Mod}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Eltwise\+Cmp\+Sub\+Mod()}{EltwiseCmpSubMod()}}
{\footnotesize\ttfamily void intel\+::hexl\+::\+Eltwise\+Cmp\+Sub\+Mod (\begin{DoxyParamCaption}\item[{uint64\+\_\+t $\ast$}]{result,  }\item[{const uint64\+\_\+t $\ast$}]{operand1,  }\item[{uint64\+\_\+t}]{n,  }\item[{uint64\+\_\+t}]{modulus,  }\item[{\hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006}{C\+M\+P\+I\+NT}}]{cmp,  }\item[{uint64\+\_\+t}]{bound,  }\item[{uint64\+\_\+t}]{diff }\end{DoxyParamCaption})}



Computes element-\/wise conditional modular subtraction. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em result} & Stores the result \\
\hline
\mbox{\tt in}  & {\em operand1} & Vector of elements to compare \\
\hline
\mbox{\tt in}  & {\em n} & Number of elements in {\ttfamily operand1} \\
\hline
\mbox{\tt in}  & {\em modulus} & Modulus to reduce by \\
\hline
\mbox{\tt in}  & {\em cmp} & Comparison function \\
\hline
\mbox{\tt in}  & {\em bound} & Scalar to compare against \\
\hline
\mbox{\tt in}  & {\em diff} & Scalar to subtract by\\
\hline
\end{DoxyParams}
Computes {\ttfamily operand1}\mbox{[}i\mbox{]} = ({\ttfamily cmp}({\ttfamily operand1}, {\ttfamily bound})) ? ({\ttfamily operand1} -\/ {\ttfamily diff}) mod {\ttfamily modulus} \+: {\ttfamily operand1} for all i=0, ..., n-\/1 \mbox{\Hypertarget{namespaceintel_1_1hexl_a5b65d563391b4a1a5041633aeb118aa5}\label{namespaceintel_1_1hexl_a5b65d563391b4a1a5041633aeb118aa5}} 
\index{intel\+::hexl@{intel\+::hexl}!Eltwise\+F\+M\+A\+Mod@{Eltwise\+F\+M\+A\+Mod}}
\index{Eltwise\+F\+M\+A\+Mod@{Eltwise\+F\+M\+A\+Mod}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Eltwise\+F\+M\+A\+Mod()}{EltwiseFMAMod()}}
{\footnotesize\ttfamily void intel\+::hexl\+::\+Eltwise\+F\+M\+A\+Mod (\begin{DoxyParamCaption}\item[{uint64\+\_\+t $\ast$}]{result,  }\item[{const uint64\+\_\+t $\ast$}]{arg1,  }\item[{uint64\+\_\+t}]{arg2,  }\item[{const uint64\+\_\+t $\ast$}]{arg3,  }\item[{uint64\+\_\+t}]{n,  }\item[{uint64\+\_\+t}]{modulus,  }\item[{uint64\+\_\+t}]{input\+\_\+mod\+\_\+factor }\end{DoxyParamCaption})}



Computes fused multiply-\/add ({\ttfamily arg1} $\ast$ {\ttfamily arg2} + {\ttfamily arg3}) mod {\ttfamily modulus} element-\/wise, broadcasting scalars to vectors. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em result} & Stores the result \\
\hline
\mbox{\tt in}  & {\em arg1} & Vector to multiply \\
\hline
\mbox{\tt in}  & {\em arg2} & Scalar to multiply \\
\hline
\mbox{\tt in}  & {\em arg3} & Vector to add. Will not add if {\ttfamily arg3} == nullptr \\
\hline
\mbox{\tt in}  & {\em n} & Number of elements in each vector \\
\hline
\mbox{\tt in}  & {\em modulus} & Modulus with which to perform modular reduction. Must be in the range $ [2, 2^{61} - 1]$ \\
\hline
\mbox{\tt in}  & {\em input\+\_\+mod\+\_\+factor} & Assumes input elements are in \mbox{[}0, input\+\_\+mod\+\_\+factor $\ast$ modulus). Must be 1, 2, 4, or 8. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceintel_1_1hexl_a705bc0321d937ae4d1f8d50279e3cff1}\label{namespaceintel_1_1hexl_a705bc0321d937ae4d1f8d50279e3cff1}} 
\index{intel\+::hexl@{intel\+::hexl}!Eltwise\+Mult\+Mod@{Eltwise\+Mult\+Mod}}
\index{Eltwise\+Mult\+Mod@{Eltwise\+Mult\+Mod}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Eltwise\+Mult\+Mod()}{EltwiseMultMod()}}
{\footnotesize\ttfamily void intel\+::hexl\+::\+Eltwise\+Mult\+Mod (\begin{DoxyParamCaption}\item[{uint64\+\_\+t $\ast$}]{result,  }\item[{const uint64\+\_\+t $\ast$}]{operand1,  }\item[{const uint64\+\_\+t $\ast$}]{operand2,  }\item[{uint64\+\_\+t}]{n,  }\item[{uint64\+\_\+t}]{modulus,  }\item[{uint64\+\_\+t}]{input\+\_\+mod\+\_\+factor }\end{DoxyParamCaption})}



Multiplies two vectors elementwise with modular reduction. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em result} & Result of element-\/wise multiplication \\
\hline
\mbox{\tt in}  & {\em operand1} & Vector of elements to multiply. Each element must be less than the modulus. \\
\hline
\mbox{\tt in}  & {\em operand2} & Vector of elements to multiply. Each element must be less than the modulus. \\
\hline
\mbox{\tt in}  & {\em n} & Number of elements in each vector \\
\hline
\mbox{\tt in}  & {\em modulus} & Modulus with which to perform modular reduction \\
\hline
\mbox{\tt in}  & {\em input\+\_\+mod\+\_\+factor} & Assumes input elements are in \mbox{[}0, input\+\_\+mod\+\_\+factor $\ast$ p) Must be 1, 2 or 4.\\
\hline
\end{DoxyParams}
Computes {\ttfamily result}\mbox{[}i\mbox{]} = ({\ttfamily operand1}\mbox{[}i\mbox{]} $\ast$ {\ttfamily operand2}\mbox{[}i\mbox{]}) mod {\ttfamily modulus} for i=0, ..., {\ttfamily n} -\/ 1 \mbox{\Hypertarget{namespaceintel_1_1hexl_af3ddae165283841d495a322275baf5ee}\label{namespaceintel_1_1hexl_af3ddae165283841d495a322275baf5ee}} 
\index{intel\+::hexl@{intel\+::hexl}!Eltwise\+Reduce\+Mod@{Eltwise\+Reduce\+Mod}}
\index{Eltwise\+Reduce\+Mod@{Eltwise\+Reduce\+Mod}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Eltwise\+Reduce\+Mod()}{EltwiseReduceMod()}}
{\footnotesize\ttfamily void intel\+::hexl\+::\+Eltwise\+Reduce\+Mod (\begin{DoxyParamCaption}\item[{uint64\+\_\+t $\ast$}]{result,  }\item[{const uint64\+\_\+t $\ast$}]{operand,  }\item[{uint64\+\_\+t}]{n,  }\item[{uint64\+\_\+t}]{modulus,  }\item[{uint64\+\_\+t}]{input\+\_\+mod\+\_\+factor,  }\item[{uint64\+\_\+t}]{output\+\_\+mod\+\_\+factor }\end{DoxyParamCaption})}



Performs elementwise modular reduction. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em result} & Stores the result \\
\hline
\mbox{\tt in}  & {\em operand} & Data on which to compute the elementwise modular reduction \\
\hline
\mbox{\tt in}  & {\em n} & Number of elements in operand \\
\hline
\mbox{\tt in}  & {\em modulus} & Modulus with which to perform modular reduction \\
\hline
\mbox{\tt in}  & {\em input\+\_\+mod\+\_\+factor} & Assumes input elements are in \mbox{[}0, input\+\_\+mod\+\_\+factor $\ast$ p) Must be 0, 1, 2 or 4. input\+\_\+mod\+\_\+factor=0 means, no knowledge of input range. Barrett reduction will be used in this case. input\+\_\+mod\+\_\+factor $>$= output\+\_\+mod\+\_\+factor unless input\+\_\+mod\+\_\+factor == 0 \\
\hline
\mbox{\tt in}  & {\em output\+\_\+mod\+\_\+factor} & output elements will be in \mbox{[}0, output\+\_\+mod\+\_\+factor $\ast$ modulus) Must be 1 or 2. For input\+\_\+mod\+\_\+factor=0, output\+\_\+mod\+\_\+factor will be set to 1. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceintel_1_1hexl_a6a45c30bc21b9b1e1410b23fce5424c8}\label{namespaceintel_1_1hexl_a6a45c30bc21b9b1e1410b23fce5424c8}} 
\index{intel\+::hexl@{intel\+::hexl}!Eltwise\+Sub\+Mod@{Eltwise\+Sub\+Mod}}
\index{Eltwise\+Sub\+Mod@{Eltwise\+Sub\+Mod}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Eltwise\+Sub\+Mod()}{EltwiseSubMod()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void intel\+::hexl\+::\+Eltwise\+Sub\+Mod (\begin{DoxyParamCaption}\item[{uint64\+\_\+t $\ast$}]{result,  }\item[{const uint64\+\_\+t $\ast$}]{operand1,  }\item[{const uint64\+\_\+t $\ast$}]{operand2,  }\item[{uint64\+\_\+t}]{n,  }\item[{uint64\+\_\+t}]{modulus }\end{DoxyParamCaption})}



Subtracts two vectors elementwise with modular reduction. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em result} & Stores result \\
\hline
\mbox{\tt in}  & {\em operand1} & Vector of elements to subtract from. Each element must be less than the modulus \\
\hline
\mbox{\tt in}  & {\em operand2} & Vector of elements to subtract. Each element must be less than the modulus \\
\hline
\mbox{\tt in}  & {\em n} & Number of elements in each vector \\
\hline
\mbox{\tt in}  & {\em modulus} & Modulus with which to perform modular reduction. Must be in the range $[2, 2^{63} - 1]$\\
\hline
\end{DoxyParams}
Computes $ operand1[i] = (operand1[i] - operand2[i]) \mod modulus $ for $ i=0, ..., n-1$. \mbox{\Hypertarget{namespaceintel_1_1hexl_abc13b8f383d3af6471a5261ee2213b40}\label{namespaceintel_1_1hexl_abc13b8f383d3af6471a5261ee2213b40}} 
\index{intel\+::hexl@{intel\+::hexl}!Eltwise\+Sub\+Mod@{Eltwise\+Sub\+Mod}}
\index{Eltwise\+Sub\+Mod@{Eltwise\+Sub\+Mod}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Eltwise\+Sub\+Mod()}{EltwiseSubMod()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void intel\+::hexl\+::\+Eltwise\+Sub\+Mod (\begin{DoxyParamCaption}\item[{uint64\+\_\+t $\ast$}]{result,  }\item[{const uint64\+\_\+t $\ast$}]{operand1,  }\item[{uint64\+\_\+t}]{operand2,  }\item[{uint64\+\_\+t}]{n,  }\item[{uint64\+\_\+t}]{modulus }\end{DoxyParamCaption})}



Subtracts a scalar from a vector elementwise with modular reduction. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em result} & Stores result \\
\hline
\mbox{\tt in}  & {\em operand1} & Vector of elements to subtract from. Each element must be less than the modulus \\
\hline
\mbox{\tt in}  & {\em operand2} & Elements to subtract. Each element must be less than the modulus \\
\hline
\mbox{\tt in}  & {\em n} & Number of elements in each vector \\
\hline
\mbox{\tt in}  & {\em modulus} & Modulus with which to perform modular reduction. Must be in the range $[2, 2^{63} - 1]$\\
\hline
\end{DoxyParams}
Computes $ operand1[i] = (operand1[i] - operand2) \mod modulus $ for $ i=0, ..., n-1$. \mbox{\Hypertarget{namespaceintel_1_1hexl_a3a8c240e5282f1d89c281527a842ae3d}\label{namespaceintel_1_1hexl_a3a8c240e5282f1d89c281527a842ae3d}} 
\index{intel\+::hexl@{intel\+::hexl}!Generate\+Primes@{Generate\+Primes}}
\index{Generate\+Primes@{Generate\+Primes}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Generate\+Primes()}{GeneratePrimes()}}
{\footnotesize\ttfamily std\+::vector$<$uint64\+\_\+t$>$ intel\+::hexl\+::\+Generate\+Primes (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{num\+\_\+primes,  }\item[{size\+\_\+t}]{bit\+\_\+size,  }\item[{bool}]{prefer\+\_\+small\+\_\+primes,  }\item[{size\+\_\+t}]{ntt\+\_\+size = {\ttfamily 1} }\end{DoxyParamCaption})}



Generates a list of num\+\_\+primes primes in the range \mbox{[}2$^\wedge$(bit\+\_\+size),. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em num\+\_\+primes} & Number of primes to generate \\
\hline
\mbox{\tt in}  & {\em bit\+\_\+size} & Bit size of each prime \\
\hline
\mbox{\tt in}  & {\em prefer\+\_\+small\+\_\+primes} & When true, returns primes starting from 2$^\wedge$(bit\+\_\+size); when false, returns primes starting from 2$^\wedge$(bit\+\_\+size+1) \\
\hline
\mbox{\tt in}  & {\em ntt\+\_\+size} & N such that each prime q satisfies q \% (2N) == 1. N must be a power of two less than 2$^\wedge$bit\+\_\+size. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceintel_1_1hexl_a130d3fb9218c1aaa9fbeb5d143eb288b}\label{namespaceintel_1_1hexl_a130d3fb9218c1aaa9fbeb5d143eb288b}} 
\index{intel\+::hexl@{intel\+::hexl}!Generate\+Primitive\+Root@{Generate\+Primitive\+Root}}
\index{Generate\+Primitive\+Root@{Generate\+Primitive\+Root}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Generate\+Primitive\+Root()}{GeneratePrimitiveRoot()}}
{\footnotesize\ttfamily uint64\+\_\+t intel\+::hexl\+::\+Generate\+Primitive\+Root (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{degree,  }\item[{uint64\+\_\+t}]{modulus }\end{DoxyParamCaption})}



Tries to return a primitive degree-\/th root of unity. 

Returns 0 or throws an error if no root is found \mbox{\Hypertarget{namespaceintel_1_1hexl_ac949027d43c64d65400c93a148d349c6}\label{namespaceintel_1_1hexl_ac949027d43c64d65400c93a148d349c6}} 
\index{intel\+::hexl@{intel\+::hexl}!Inverse\+Mod@{Inverse\+Mod}}
\index{Inverse\+Mod@{Inverse\+Mod}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Inverse\+Mod()}{InverseMod()}}
{\footnotesize\ttfamily uint64\+\_\+t intel\+::hexl\+::\+Inverse\+Mod (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{x,  }\item[{uint64\+\_\+t}]{modulus }\end{DoxyParamCaption})}



Returns x$^\wedge$\{-\/1\} mod modulus. 

Requires x \% modulus != 0 \mbox{\Hypertarget{namespaceintel_1_1hexl_a74a77227ebbd892a0cff5089f3d89010}\label{namespaceintel_1_1hexl_a74a77227ebbd892a0cff5089f3d89010}} 
\index{intel\+::hexl@{intel\+::hexl}!Is\+Power\+Of\+Four@{Is\+Power\+Of\+Four}}
\index{Is\+Power\+Of\+Four@{Is\+Power\+Of\+Four}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Is\+Power\+Of\+Four()}{IsPowerOfFour()}}
{\footnotesize\ttfamily bool intel\+::hexl\+::\+Is\+Power\+Of\+Four (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{num }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{namespaceintel_1_1hexl_ada0fe74afb4384b54728cba8ec3f69cd}\label{namespaceintel_1_1hexl_ada0fe74afb4384b54728cba8ec3f69cd}} 
\index{intel\+::hexl@{intel\+::hexl}!Is\+Power\+Of\+Two@{Is\+Power\+Of\+Two}}
\index{Is\+Power\+Of\+Two@{Is\+Power\+Of\+Two}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Is\+Power\+Of\+Two()}{IsPowerOfTwo()}}
{\footnotesize\ttfamily bool intel\+::hexl\+::\+Is\+Power\+Of\+Two (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{num }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Returns whether or not num is a power of two. 

\mbox{\Hypertarget{namespaceintel_1_1hexl_a1155b31afc84bd8a7080d49b66480395}\label{namespaceintel_1_1hexl_a1155b31afc84bd8a7080d49b66480395}} 
\index{intel\+::hexl@{intel\+::hexl}!Is\+Prime@{Is\+Prime}}
\index{Is\+Prime@{Is\+Prime}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Is\+Prime()}{IsPrime()}}
{\footnotesize\ttfamily bool intel\+::hexl\+::\+Is\+Prime (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{n }\end{DoxyParamCaption})}



Returns whether or not the input is prime. 

\mbox{\Hypertarget{namespaceintel_1_1hexl_a8b04aa9aed381d3c976d953efbe0a4b6}\label{namespaceintel_1_1hexl_a8b04aa9aed381d3c976d953efbe0a4b6}} 
\index{intel\+::hexl@{intel\+::hexl}!Is\+Primitive\+Root@{Is\+Primitive\+Root}}
\index{Is\+Primitive\+Root@{Is\+Primitive\+Root}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Is\+Primitive\+Root()}{IsPrimitiveRoot()}}
{\footnotesize\ttfamily bool intel\+::hexl\+::\+Is\+Primitive\+Root (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{root,  }\item[{uint64\+\_\+t}]{degree,  }\item[{uint64\+\_\+t}]{modulus }\end{DoxyParamCaption})}



Returns whether or not root is a degree-\/th root of unity mod modulus. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em root} & Root of unity to check \\
\hline
\mbox{\tt in}  & {\em degree} & Degree of root of unity; must be a power of two \\
\hline
\mbox{\tt in}  & {\em modulus} & Modulus of finite field \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceintel_1_1hexl_a066a83a4b122279313279a58cf440004}\label{namespaceintel_1_1hexl_a066a83a4b122279313279a58cf440004}} 
\index{intel\+::hexl@{intel\+::hexl}!Log2@{Log2}}
\index{Log2@{Log2}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Log2()}{Log2()}}
{\footnotesize\ttfamily uint64\+\_\+t intel\+::hexl\+::\+Log2 (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{x }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Returns floor(log2(x)) 

\mbox{\Hypertarget{namespaceintel_1_1hexl_a9975ccaf5ec051c07ff4e3fef5c1fefb}\label{namespaceintel_1_1hexl_a9975ccaf5ec051c07ff4e3fef5c1fefb}} 
\index{intel\+::hexl@{intel\+::hexl}!Maximum\+Value@{Maximum\+Value}}
\index{Maximum\+Value@{Maximum\+Value}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Maximum\+Value()}{MaximumValue()}}
{\footnotesize\ttfamily uint64\+\_\+t intel\+::hexl\+::\+Maximum\+Value (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{bits }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Returns the maximum value that can be represented using {\ttfamily bits} bits. 

\mbox{\Hypertarget{namespaceintel_1_1hexl_adcc30a762adcbbdc9d7ebefa6fffe83b}\label{namespaceintel_1_1hexl_adcc30a762adcbbdc9d7ebefa6fffe83b}} 
\index{intel\+::hexl@{intel\+::hexl}!Minimal\+Primitive\+Root@{Minimal\+Primitive\+Root}}
\index{Minimal\+Primitive\+Root@{Minimal\+Primitive\+Root}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Minimal\+Primitive\+Root()}{MinimalPrimitiveRoot()}}
{\footnotesize\ttfamily uint64\+\_\+t intel\+::hexl\+::\+Minimal\+Primitive\+Root (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{degree,  }\item[{uint64\+\_\+t}]{modulus }\end{DoxyParamCaption})}



Returns whether or not root is a degree-\/th root of unity. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em degree} & Must be a power of two \\
\hline
\mbox{\tt in}  & {\em modulus} & Modulus of finite field \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceintel_1_1hexl_a838d9c2d540f99b349546461dee63252}\label{namespaceintel_1_1hexl_a838d9c2d540f99b349546461dee63252}} 
\index{intel\+::hexl@{intel\+::hexl}!Multiply\+Mod@{Multiply\+Mod}}
\index{Multiply\+Mod@{Multiply\+Mod}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Multiply\+Mod()}{MultiplyMod()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily uint64\+\_\+t intel\+::hexl\+::\+Multiply\+Mod (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{x,  }\item[{uint64\+\_\+t}]{y,  }\item[{uint64\+\_\+t}]{modulus }\end{DoxyParamCaption})}



Returns (x $\ast$ y) mod modulus. 

Assumes x, y $<$ modulus \mbox{\Hypertarget{namespaceintel_1_1hexl_a0b3d06107428b15f58be1680fbf1656d}\label{namespaceintel_1_1hexl_a0b3d06107428b15f58be1680fbf1656d}} 
\index{intel\+::hexl@{intel\+::hexl}!Multiply\+Mod@{Multiply\+Mod}}
\index{Multiply\+Mod@{Multiply\+Mod}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Multiply\+Mod()}{MultiplyMod()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily uint64\+\_\+t intel\+::hexl\+::\+Multiply\+Mod (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{x,  }\item[{uint64\+\_\+t}]{y,  }\item[{uint64\+\_\+t}]{y\+\_\+precon,  }\item[{uint64\+\_\+t}]{modulus }\end{DoxyParamCaption})}



Returns (x $\ast$ y) mod modulus. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em x} & \\
\hline
\mbox{\tt in}  & {\em y} & \\
\hline
\mbox{\tt in}  & {\em y\+\_\+precon} & 64-\/bit precondition factor floor(2$\ast$$\ast$64 / modulus) \\
\hline
\mbox{\tt in}  & {\em modulus} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceintel_1_1hexl_ad7a9d35f74908eca9240bc7675705976}\label{namespaceintel_1_1hexl_ad7a9d35f74908eca9240bc7675705976}} 
\index{intel\+::hexl@{intel\+::hexl}!Multiply\+Mod\+Lazy@{Multiply\+Mod\+Lazy}}
\index{Multiply\+Mod\+Lazy@{Multiply\+Mod\+Lazy}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Multiply\+Mod\+Lazy()}{MultiplyModLazy()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int Bit\+Shift$>$ \\
uint64\+\_\+t intel\+::hexl\+::\+Multiply\+Mod\+Lazy (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{x,  }\item[{uint64\+\_\+t}]{y\+\_\+operand,  }\item[{uint64\+\_\+t}]{y\+\_\+barrett\+\_\+factor,  }\item[{uint64\+\_\+t}]{modulus }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Computes (x $\ast$ y) mod modulus, except that the output is in \mbox{[}0, 2 $\ast$ modulus\mbox{]}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em x} & \\
\hline
\mbox{\tt in}  & {\em y\+\_\+operand} & also denoted y \\
\hline
\mbox{\tt in}  & {\em modulus} & \\
\hline
\mbox{\tt in}  & {\em y\+\_\+barrett\+\_\+factor} & Pre-\/computed Barrett reduction factor floor((y $<$$<$ Bit\+Shift) / modulus) \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceintel_1_1hexl_a8f6c714aff229c45fbba359cc67331a5}\label{namespaceintel_1_1hexl_a8f6c714aff229c45fbba359cc67331a5}} 
\index{intel\+::hexl@{intel\+::hexl}!Multiply\+Mod\+Lazy@{Multiply\+Mod\+Lazy}}
\index{Multiply\+Mod\+Lazy@{Multiply\+Mod\+Lazy}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Multiply\+Mod\+Lazy()}{MultiplyModLazy()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int Bit\+Shift$>$ \\
uint64\+\_\+t intel\+::hexl\+::\+Multiply\+Mod\+Lazy (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{x,  }\item[{uint64\+\_\+t}]{y,  }\item[{uint64\+\_\+t}]{modulus }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Computes (x $\ast$ y) mod modulus, except that the output is in \mbox{[}0, 2 $\ast$ modulus\mbox{]}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em x} & \\
\hline
\mbox{\tt in}  & {\em y} & \\
\hline
\mbox{\tt in}  & {\em modulus} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceintel_1_1hexl_a8c654502a5e7fe2cfdd198f0fd920f2a}\label{namespaceintel_1_1hexl_a8c654502a5e7fe2cfdd198f0fd920f2a}} 
\index{intel\+::hexl@{intel\+::hexl}!Not@{Not}}
\index{Not@{Not}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Not()}{Not()}}
{\footnotesize\ttfamily \hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006}{C\+M\+P\+I\+NT} intel\+::hexl\+::\+Not (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006}{C\+M\+P\+I\+NT}}]{cmp }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Returns the logical negation of a binary operation. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em cmp} & The binary operation to negate \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceintel_1_1hexl_aff7287aeef7fdb27e6ffb254adb40477}\label{namespaceintel_1_1hexl_aff7287aeef7fdb27e6ffb254adb40477}} 
\index{intel\+::hexl@{intel\+::hexl}!Pow\+Mod@{Pow\+Mod}}
\index{Pow\+Mod@{Pow\+Mod}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Pow\+Mod()}{PowMod()}}
{\footnotesize\ttfamily uint64\+\_\+t intel\+::hexl\+::\+Pow\+Mod (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{base,  }\item[{uint64\+\_\+t}]{exp,  }\item[{uint64\+\_\+t}]{modulus }\end{DoxyParamCaption})}



Returns base$^\wedge$exp mod modulus. 

\mbox{\Hypertarget{namespaceintel_1_1hexl_ab716e0395cbfe58e76f866a9044f2a62}\label{namespaceintel_1_1hexl_ab716e0395cbfe58e76f866a9044f2a62}} 
\index{intel\+::hexl@{intel\+::hexl}!Reduce\+Mod@{Reduce\+Mod}}
\index{Reduce\+Mod@{Reduce\+Mod}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Reduce\+Mod()}{ReduceMod()}}
{\footnotesize\ttfamily template$<$int Input\+Mod\+Factor$>$ \\
uint64\+\_\+t intel\+::hexl\+::\+Reduce\+Mod (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{x,  }\item[{uint64\+\_\+t}]{modulus,  }\item[{const uint64\+\_\+t $\ast$}]{twice\+\_\+modulus = {\ttfamily nullptr},  }\item[{const uint64\+\_\+t $\ast$}]{four\+\_\+times\+\_\+modulus = {\ttfamily nullptr} }\end{DoxyParamCaption})}



Returns x mod modulus, assuming x $<$ Input\+Mod\+Factor $\ast$ modulus. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em x} & \\
\hline
\mbox{\tt in}  & {\em modulus} & also denoted q \\
\hline
\mbox{\tt in}  & {\em twice\+\_\+modulus} & 2 $\ast$ q; must not be nullptr if Input\+Mod\+Factor == 4 or 8 \\
\hline
\mbox{\tt in}  & {\em four\+\_\+times\+\_\+modulus} & 4 $\ast$ q; must not be nullptr if Input\+Mod\+Factor == 8 \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceintel_1_1hexl_aa48183a39af615227d5b14c0fdb46105}\label{namespaceintel_1_1hexl_aa48183a39af615227d5b14c0fdb46105}} 
\index{intel\+::hexl@{intel\+::hexl}!Reverse\+Bits@{Reverse\+Bits}}
\index{Reverse\+Bits@{Reverse\+Bits}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Reverse\+Bits()}{ReverseBits()}}
{\footnotesize\ttfamily uint64\+\_\+t intel\+::hexl\+::\+Reverse\+Bits (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{x,  }\item[{uint64\+\_\+t}]{bit\+\_\+width }\end{DoxyParamCaption})}



Reverses the bits. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em x} & Input to reverse \\
\hline
\mbox{\tt in}  & {\em bit\+\_\+width} & Number of bits in the input; must be $>$= M\+S\+B(x) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The bit-\/reversed representation of {\ttfamily x} using {\ttfamily bit\+\_\+width} bits 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceintel_1_1hexl_a4411ec648d83bfbc3ecaf96859576054}\label{namespaceintel_1_1hexl_a4411ec648d83bfbc3ecaf96859576054}} 
\index{intel\+::hexl@{intel\+::hexl}!Sub\+U\+Int\+Mod@{Sub\+U\+Int\+Mod}}
\index{Sub\+U\+Int\+Mod@{Sub\+U\+Int\+Mod}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Sub\+U\+Int\+Mod()}{SubUIntMod()}}
{\footnotesize\ttfamily uint64\+\_\+t intel\+::hexl\+::\+Sub\+U\+Int\+Mod (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{x,  }\item[{uint64\+\_\+t}]{y,  }\item[{uint64\+\_\+t}]{modulus }\end{DoxyParamCaption})}



Returns (x -\/ y) mod modulus. 

Assumes x, y $<$ modulus 

\subsection{Variable Documentation}
\mbox{\Hypertarget{namespaceintel_1_1hexl_aedc86b34ea92ac34d036acff6d84479a}\label{namespaceintel_1_1hexl_aedc86b34ea92ac34d036acff6d84479a}} 
\index{intel\+::hexl@{intel\+::hexl}!malloc\+Strategy@{malloc\+Strategy}}
\index{malloc\+Strategy@{malloc\+Strategy}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{malloc\+Strategy}{mallocStrategy}}
{\footnotesize\ttfamily \hyperlink{namespaceintel_1_1hexl_aced64250965d3b78827d8009634eef0c}{Allocator\+Strategy\+Ptr} intel\+::hexl\+::malloc\+Strategy}

