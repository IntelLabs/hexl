Intel\+:registered\+: H\+E\+XL is an open-\/source library which provides efficient implementations of integer arithmetic on Galois fields. Such arithmetic is prevalent in cryptography, particularly in homomorphic encryption (HE) schemes. Intel H\+E\+XL targets integer arithmetic with word-\/sized primes, typically 40-\/60 bits. Intel H\+E\+XL provides an A\+PI for 64-\/bit unsigned integers and targets Intel C\+P\+Us. For more details on Intel H\+E\+XL, see our \href{https://arxiv.org/abs/2103.16400.pdf}{\tt whitepaper}

\subsection*{Contents}


\begin{DoxyItemize}
\item \href{#intel-homomorphic-encryption-acceleration-library-hexl}{\tt Intel Homomorphic Encryption Acceleration Library (H\+E\+XL)}
\begin{DoxyItemize}
\item \href{#contents}{\tt Contents}
\item \href{#introduction}{\tt Introduction}
\item \href{#building-intel-hexl}{\tt Building Intel H\+E\+XL}
\begin{DoxyItemize}
\item \href{#dependencies}{\tt Dependencies}
\item \href{#compile-time-options}{\tt Compile-\/time options}
\item \href{#compiling-intel-hexl}{\tt Compiling Intel H\+E\+XL}
\begin{DoxyItemize}
\item \href{#linux-and-mac}{\tt Linux and Mac}
\item \href{#windows}{\tt Windows}
\end{DoxyItemize}
\end{DoxyItemize}
\item \href{#testing-intel-hexl}{\tt Testing Intel H\+E\+XL}
\item \href{#benchmarking-intel-hexl}{\tt Benchmarking Intel H\+E\+XL}
\item \href{#using-intel-hexl}{\tt Using Intel H\+E\+XL}
\item \href{#debugging}{\tt Debugging}
\item \href{#threading}{\tt Threading}
\end{DoxyItemize}
\item \href{#community-adoption}{\tt Community Adoption}
\item \href{#documentation}{\tt Documentation}
\item \href{#contributing}{\tt Contributing}
\begin{DoxyItemize}
\item \href{#repository-layout}{\tt Repository layout}
\end{DoxyItemize}
\item \href{#citing-intel-hexl}{\tt Citing Intel H\+E\+XL}
\begin{DoxyItemize}
\item \href{#version-12}{\tt Version 1.\+2}
\item \href{#version-11}{\tt Version 1.\+1}
\item \href{#version-10}{\tt Version 1.\+0}
\end{DoxyItemize}
\item \href{#contributors}{\tt Contributors}
\end{DoxyItemize}

\subsection*{Introduction}

Many cryptographic applications, particularly homomorphic encryption (HE), rely on integer polynomial arithmetic in a finite field. HE, which enables computation on encrypted data, typically uses polynomials with degree {\ttfamily N} a power of two roughly in the range {\ttfamily N=\mbox{[}2$^\wedge$\{10\}, 2$^\wedge$\{17\}\mbox{]}}. The coefficients of these polynomials are in a finite field with a word-\/sized prime, {\ttfamily q}, up to {\ttfamily q}$\sim$62 bits. More precisely, the polynomials live in the ring {\ttfamily Z\+\_\+q\mbox{[}X\mbox{]}/(X$^\wedge$N + 1)}. That is, when adding or multiplying two polynomials, each coefficient of the result is reduced by the prime modulus {\ttfamily q}. When multiplying two polynomials, the resulting polynomials of degree {\ttfamily 2N} is additionally reduced by taking the remainder when dividing by {\ttfamily X$^\wedge$\+N+1}.

The primary bottleneck in many HE applications is polynomial-\/polynomial multiplication in {\ttfamily Z\+\_\+q\mbox{[}X\mbox{]}/(X$^\wedge$N + 1)}. For efficient implementation, Intel H\+E\+XL implements the negacyclic number-\/theoretic transform (N\+TT). To multiply two polynomials, {\ttfamily q\+\_\+1(x), q\+\_\+2(x)} using the N\+TT, we perform the Fwd\+N\+TT on the two input polynomials, then perform an element-\/wise modular multiplication, and perform the Inv\+N\+TT on the result.

Intel H\+E\+XL implements the following functions\+:
\begin{DoxyItemize}
\item The forward and inverse negacyclic number-\/theoretic transform (N\+TT)
\item Element-\/wise vector-\/vector modular multiplication
\item Element-\/wise vector-\/scalar modular multiplication with optional addition
\item Element-\/wise modular multiplication
\end{DoxyItemize}

For each function, the library implements one or several Intel(\+R) A\+V\+X-\/512 implementations, as well as a less performant, more readable native C++ implementation. Intel H\+E\+XL will automatically choose the best implementation for the given C\+PU Intel(\+R) A\+V\+X-\/512 feature set. In particular, when the modulus {\ttfamily q} is less than {\ttfamily 2$^\wedge$\{50\}}, the A\+V\+X512\+I\+F\+MA instruction set available on Intel Ice\+Lake server and Ice\+Lake client will provide a more efficient implementation.

For additional functionality, see the public headers, located in {\ttfamily include/hexl}

\subsection*{Building Intel H\+E\+XL}

Intel H\+E\+XL can be built in several ways. Intel H\+E\+XL has been uploaded to the \href{https://github.com/microsoft/vcpkg}{\tt Microsoft vcpkg} C++ package manager, which supports Linux, mac\+OS, and Windows builds. See the vcpkg repository for instructions to build Intel H\+E\+XL with vcpkg, e.\+g. run {\ttfamily vcpkg install hexl}. There may be some delay in uploading latest release ports to vcpkg. Intel H\+E\+XL provides port files to build the latest version with vcpkg. For a static build, run {\ttfamily vcpkg install hexl -\/-\/overlay-\/ports=/path/to/hexl/port/hexl -\/-\/head}. For dynamic build, use the custom triplet file and run {\ttfamily vcpkg install hexl\+:hexl-\/dynamic-\/build -\/-\/overlay-\/ports=/path/to/hexl/port/hexl -\/-\/head -\/-\/overlay-\/triplets=/path/to/hexl/port/hexl}. For detailed explanation, see \href{https://devblogs.microsoft.com/cppblog/registries-bring-your-own-libraries-to-vcpkg/}{\tt instruction} for building vcpkg port using overlays and use of \href{https://github.com/microsoft/vcpkg/blob/master/docs/examples/overlay-triplets-linux-dynamic.md#building-dynamic-libraries-on-linux}{\tt custom triplet} provided by vcpkg.

Intel H\+E\+XL also supports a build using the C\+Make build system. See below for the instructions to build Intel H\+E\+XL from source using C\+Make.

\subsubsection*{Dependencies}

We have tested Intel H\+E\+XL on the following operating systems\+:
\begin{DoxyItemize}
\item Ubuntu 20.\+04
\item mac\+OS 10.\+15
\item Microsoft Windows 10
\end{DoxyItemize}

Intel H\+E\+XL requires the following dependencies\+:

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Dependency }&\textbf{ Version  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Dependency }&\textbf{ Version  }\\\cline{1-2}
\endhead
C\+Make &$>$= 3.\+5.\+1 \\\cline{1-2}
Compiler &gcc $>$= 7.\+0, clang++ $>$= 5.\+0, M\+S\+VC $>$= 2019 \\\cline{1-2}
\end{longtabu}
For best performance, we recommend compiling with clang++-\/12. We also recommend using a processor with Intel A\+V\+X512\+DQ support, with best performance on processors supporting Intel A\+V\+X512-\/\+I\+F\+M\+A52. To determine if your processor supports A\+V\+X512-\/\+I\+F\+M\+A52, simply look for {\ttfamily H\+E\+X\+L\+\_\+\+H\+A\+S\+\_\+\+A\+V\+X512\+I\+F\+MA} during the configure step (see \href{#compiling-intel-hexl}{\tt Compiling Intel H\+E\+XL}).

\subsubsection*{Compile-\/time options}

In addition to the standard C\+Make build options, Intel H\+E\+XL supports several compile-\/time flags to configure the build. For convenience, they are listed below\+:

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ C\+Make option }&\textbf{ Values }&\textbf{ }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ C\+Make option }&\textbf{ Values }&\textbf{ }\\\cline{1-3}
\endhead
H\+E\+X\+L\+\_\+\+B\+E\+N\+C\+H\+M\+A\+RK &ON / O\+FF (default ON) &Set to ON to enable benchmark suite via Google benchmark \\\cline{1-3}
H\+E\+X\+L\+\_\+\+C\+O\+V\+E\+R\+A\+GE &ON / O\+FF (default O\+FF) &Set to ON to enable coverage report of unit-\/tests \\\cline{1-3}
H\+E\+X\+L\+\_\+\+D\+O\+CS &ON / O\+FF (default O\+FF) &Set to ON to enable building of documentation \\\cline{1-3}
H\+E\+X\+L\+\_\+\+S\+H\+A\+R\+E\+D\+\_\+\+L\+IB &ON / O\+FF (default O\+FF) &Set to ON to enable building shared library \\\cline{1-3}
H\+E\+X\+L\+\_\+\+T\+E\+S\+T\+I\+NG &ON / O\+FF (default ON) &Set to ON to enable building of unit-\/tests \\\cline{1-3}
H\+E\+X\+L\+\_\+\+T\+R\+E\+A\+T\+\_\+\+W\+A\+R\+N\+I\+N\+G\+\_\+\+A\+S\+\_\+\+E\+R\+R\+OR &ON / O\+FF (default O\+FF) &Set to ON to treat all warnings as error \\\cline{1-3}
\end{longtabu}
\subsubsection*{Compiling Intel H\+E\+XL}

To compile Intel H\+E\+XL from source code, first clone the repository and change directories to the where the source has been cloned. \paragraph*{Linux and Mac}

The instructions to build Intel H\+E\+XL are common to Linux and Mac\+OS.

Then, to configure the build, call 
\begin{DoxyCode}
cmake -S . -B build
\end{DoxyCode}
 adding the desired compile-\/time options with a {\ttfamily -\/D} flag. For instance, to build Intel H\+E\+XL as a shared library, call 
\begin{DoxyCode}
cmake -S . -B build -DHEXL\_SHARED\_LIB=ON
\end{DoxyCode}


Then, to build Intel H\+E\+XL, call 
\begin{DoxyCode}
cmake --build build
\end{DoxyCode}
 This will build the Intel H\+E\+XL library in the {\ttfamily build/hexl/lib/} directory.

To install Intel H\+E\+XL to the installation directory, run 
\begin{DoxyCode}
cmake --install build
\end{DoxyCode}
 To use a non-\/standard installation directory, configure the build with 
\begin{DoxyCode}
cmake -S . -B build -DCMAKE\_INSTALL\_PREFIX=/path/to/install
\end{DoxyCode}
 before proceeding with the build and installation directions above.

\paragraph*{Windows}

To compile Intel H\+E\+XL on Windows using Visual Studio in Release mode, configure the build via 
\begin{DoxyCode}
cmake -S . -B build -G "Visual Studio 16 2019" -DCMAKE\_BUILD\_TYPE=Release
\end{DoxyCode}
 adding the desired compile-\/time options with a {\ttfamily -\/D} flag (see \href{#compile-time-options}{\tt Compile-\/time options}).

To specify the desired build configuration, pass either {\ttfamily -\/-\/config Debug} or {\ttfamily -\/-\/config Release} to the build step and install steps. For instance, to build Intel H\+E\+XL in Release mode, call 
\begin{DoxyCode}
cmake --build build --config Release
\end{DoxyCode}
 This will build the Intel H\+E\+XL library in the {\ttfamily build/hexl/lib/} or {\ttfamily build/hexl/\+Release/lib} directory.

To install Intel H\+E\+XL to the installation directory, run 
\begin{DoxyCode}
cmake --build build --target install --config Release
\end{DoxyCode}
 To use a non-\/standard installation directory, configure the build with 
\begin{DoxyCode}
cmake -S . -B build -G "Visual Studio 16 2019" -DCMAKE\_BUILD\_TYPE=Release
       -DCMAKE\_INSTALL\_PREFIX=/path/to/install
\end{DoxyCode}
 before proceeding with the build and installation directions above.

\subsection*{Testing Intel H\+E\+XL}

To run a set of unit tests via Googletest, configure and build Intel H\+E\+XL with {\ttfamily -\/\+D\+H\+E\+X\+L\+\_\+\+T\+E\+S\+T\+I\+NG=ON} (see \href{#compile-time-options}{\tt Compile-\/time options}). Then, run 
\begin{DoxyCode}
cmake --build build --target unittest
\end{DoxyCode}
 The unit-\/test executable itself is located at {\ttfamily build/test/unit-\/test} on Linux and Mac, and at {\ttfamily build\textbackslash{}test\textbackslash{}Release\textbackslash{}unit-\/test.\+exe} or {\ttfamily build\textbackslash{}test\textbackslash{}Debug\textbackslash{}unit-\/test.\+exe} on Windows. \subsection*{Benchmarking Intel H\+E\+XL}

To run a set of benchmarks via Google benchmark, configure and build Intel H\+E\+XL with {\ttfamily -\/\+D\+H\+E\+X\+L\+\_\+\+B\+E\+N\+C\+H\+M\+A\+RK=ON} (see \href{#compile-time-options}{\tt Compile-\/time options}). Then, run 
\begin{DoxyCode}
cmake --build build --target bench
\end{DoxyCode}
 On Windows, run 
\begin{DoxyCode}
cmake --build build --target bench --config Release
\end{DoxyCode}


The benchmark executable itself is located at {\ttfamily build/benchmark/bench\+\_\+hexl} on Linux and Mac, and at {\ttfamily build\textbackslash{}benchmark\textbackslash{}Debug\textbackslash{}bench\+\_\+hexl.\+exe} or {\ttfamily build\textbackslash{}benchmark\textbackslash{}Release\textbackslash{}bench\+\_\+hexl.\+exe} on Windows.

\subsection*{Using Intel H\+E\+XL}

The {\ttfamily example} folder has an example of using Intel H\+E\+XL in a third-\/party project.

\subsection*{Debugging}

For optimal performance, Intel H\+E\+XL does not perform input validation. In many cases the time required for the validation would be longer than the execution of the function itself. To debug Intel H\+E\+XL, configure and build Intel H\+E\+XL with {\ttfamily -\/\+D\+C\+M\+A\+K\+E\+\_\+\+B\+U\+I\+L\+D\+\_\+\+T\+Y\+PE=Debug} (see \href{#compile-time-options}{\tt Compile-\/time options}). This will generate a debug version of the library, e.\+g. {\ttfamily libhexl\+\_\+debug.\+a}, that can be used to debug the execution. In Debug mode, Intel H\+E\+XL will also link against \href{https://github.com/google/sanitizers/wiki/AddressSanitizer}{\tt Address Sanitizer}.

{\bfseries Note}, enabling {\ttfamily C\+M\+A\+K\+E\+\_\+\+B\+U\+I\+L\+D\+\_\+\+T\+Y\+PE=Debug} will result in a significant runtime overhead.

To enable verbose logging for the benchmarks or unit-\/tests in a Debug build, add the log level as a command-\/line argument, e.\+g. {\ttfamily build/benchmark/bench\+\_\+hexl -\/-\/v=9}. See \href{https://github.com/amrayn/easyloggingpp#application-arguments}{\tt easyloggingpp\textquotesingle{}s documentation} for more details.

\subsection*{Threading}

Intel H\+E\+XL is single-\/threaded and thread-\/safe.

\section*{Community Adoption}

Intel H\+E\+XL has been integrated to the following homomorphic encryption libraries\+:
\begin{DoxyItemize}
\item \href{https://github.com/microsoft/SEAL}{\tt Microsoft S\+E\+AL}
\item \href{https://gitlab.com/palisade/palisade-release}{\tt P\+A\+L\+I\+S\+A\+DE}
\end{DoxyItemize}

See also the \href{https://github.com/intel/he-toolkit}{\tt Intel Homomorphic Encryption Toolkit} for example uses cases using H\+E\+XL.

Please let us know if you are aware of any other uses of Intel H\+E\+XL.

\section*{Documentation}

Intel H\+E\+XL supports documentation via Doxygen. See \href{https://intel.github.io/hexl}{\tt https\+://intel.\+github.\+io/hexl} for the latest Doxygen documentation.

To build documentation, first install {\ttfamily doxygen} and {\ttfamily graphviz}, e.\+g. 
\begin{DoxyCode}
sudo apt-get install doxygen graphviz
\end{DoxyCode}
 Then, configure Intel H\+E\+XL with {\ttfamily -\/\+D\+H\+E\+X\+L\+\_\+\+D\+O\+CS=ON} (see \href{#compile-time-options}{\tt Compile-\/time options}). To build Doxygen documentation, after configuring Intel H\+E\+XL with {\ttfamily -\/\+D\+H\+E\+X\+L\+\_\+\+D\+O\+CS=ON}, run 
\begin{DoxyCode}
cmake --build build --target docs
\end{DoxyCode}
 To view the generated Doxygen documentation, open the generated {\ttfamily docs/doxygen/html/index.\+html} file in a web browser.

\section*{Contributing}

This project welcomes external contributions. To contribute to Intel H\+E\+XL, see \hyperlink{CONTRIBUTING_8md}{C\+O\+N\+T\+R\+I\+B\+U\+T\+I\+NG.md}. We encourage feedback and suggestions via \href{https://github.com/intel/hexl/issues}{\tt Github Issues} as well as discussion via \href{https://github.com/intel/hexl/discussions}{\tt Github Discussions}.

\subsection*{Repository layout}

Public headers reside in the {\ttfamily hexl/include} folder. Private headers, e.\+g. those containing Intel(\+R) A\+V\+X-\/512 code should not be put in this folder.

\section*{Citing Intel H\+E\+XL}

To cite Intel H\+E\+XL, please use the following Bib\+TeX entry.

\#\#\# Version 1.\+2 
\begin{DoxyCode}
@misc\{IntelHEXL,
    author=\{Boemer, Fabian and Kim, Sejun and Seifu, Gelila and de Souza, Fillipe DM and Gopal, Vinodh and
       others\},
    title = \{\{I\}ntel \{HEXL\} (release 1.2)\},
    howpublished = \{\(\backslash\)url\{https://github.com/intel/hexl\}\},
    month = september,
    year = 2021,
    key = \{Intel HEXL\}
\}
\end{DoxyCode}


\#\#\# Version 1.\+1 
\begin{DoxyCode}
@misc\{IntelHEXL,
    author=\{Boemer, Fabian and Kim, Sejun and Seifu, Gelila and de Souza, Fillipe DM and Gopal, Vinodh and
       others\},
    title = \{\{I\}ntel \{HEXL\} (release 1.1)\},
    howpublished = \{\(\backslash\)url\{https://github.com/intel/hexl\}\},
    month = may,
    year = 2021,
    key = \{Intel HEXL\}
\}
\end{DoxyCode}


\#\#\# Version 1.\+0 
\begin{DoxyCode}
@misc\{IntelHEXL,
    author=\{Boemer, Fabian and Kim, Sejun and Seifu, Gelila and de Souza, Fillipe DM and Gopal, Vinodh and
       others\},
    title = \{\{I\}ntel \{HEXL\} (release 1.0)\},
    howpublished = \{\(\backslash\)url\{https://github.com/intel/hexl\}\},
    month = april,
    year = 2021,
    key = \{Intel HEXL\}
\}
\end{DoxyCode}


\section*{Contributors}

The Intel contributors to this project, sorted by last name, are
\begin{DoxyItemize}
\item \href{https://www.linkedin.com/in/paky-abu-alam-89797710/}{\tt Paky Abu-\/\+Alam}
\item \href{https://www.linkedin.com/in/flavio-bergamaschi-1634141/}{\tt Flavio Bergamaschi}
\item \href{https://www.linkedin.com/in/fabian-boemer-5a40a9102/}{\tt Fabian Boemer} (lead)
\item \href{https://www.linkedin.com/in/jeremy-bottleson-38852a7/}{\tt Jeremy Bottleson}
\item \href{https://www.linkedin.com/in/jacklhcrawford/}{\tt Jack Crawford}
\item \href{https://www.linkedin.com/in/fillipe-d-m-de-souza-a8281820/}{\tt Fillipe D.\+M. de Souza}
\item \href{https://www.linkedin.com/in/sergey-ivanov-451b72195/}{\tt Sergey Ivanov}
\item \href{https://www.linkedin.com/in/akshaya-jagannadharao/}{\tt Akshaya Jagannadharao}
\item \href{https://www.linkedin.com/in/jingyi-jin-655735/}{\tt Jingyi Jin}
\item \href{https://www.linkedin.com/in/sejun-kim-2b1b4866/}{\tt Sejun Kim}
\item \href{https://www.linkedin.com/in/nir-peled-4a52266/}{\tt Nir Peled}
\item \href{https://www.linkedin.com/in/kylanrace/}{\tt Kylan Race}
\item \href{https://www.linkedin.com/in/gelila-seifu/}{\tt Gelila Seifu}
\end{DoxyItemize}

In addition to the Intel contributors listed, we are also grateful to contributions to this project that are not reflected in the Git history\+:
\begin{DoxyItemize}
\item \href{https://www.linkedin.com/in/apapadimitriou/}{\tt Antonis Papadimitriou} 
\end{DoxyItemize}